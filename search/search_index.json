{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ESP IoT Framework This frameworks intention is to simplify the development of ESP32 IoT Devices, which interact with AWS Services. The framework is complemented by the AWS IoT Framework Motivation Overview The networking of sensors and actuators via the internet is becoming increasingly important in industry, but also in the private sector. In this project work it will be shown how a processing chain from the sensor to the cloud service (AWS) can be realized practically. The project aims to provide a valuable overview of what is possible with embedded/connected IoT devices that can transmit data to the cloud. In addition, the projects goal was to provide a secure connection to AWS. Attention Please be aware that this project is a feasibility study. It does not provide code which is ready for production, or similar. Further information about the future intentions of this project can be found here. OpenSource This project can be accessed via the MIT License. Based upon this license the project team highly encourages people who are keen on getting in touch with embedded IoT applications to contribute to this project. Getting started in order to get started with developing or using the code head over to Setup","title":"Welcome"},{"location":"#esp-iot-framework","text":"This frameworks intention is to simplify the development of ESP32 IoT Devices, which interact with AWS Services. The framework is complemented by the AWS IoT Framework","title":"ESP IoT Framework"},{"location":"#motivation","text":"","title":"Motivation"},{"location":"#overview","text":"The networking of sensors and actuators via the internet is becoming increasingly important in industry, but also in the private sector. In this project work it will be shown how a processing chain from the sensor to the cloud service (AWS) can be realized practically. The project aims to provide a valuable overview of what is possible with embedded/connected IoT devices that can transmit data to the cloud. In addition, the projects goal was to provide a secure connection to AWS. Attention Please be aware that this project is a feasibility study. It does not provide code which is ready for production, or similar. Further information about the future intentions of this project can be found here.","title":"Overview"},{"location":"#opensource","text":"This project can be accessed via the MIT License. Based upon this license the project team highly encourages people who are keen on getting in touch with embedded IoT applications to contribute to this project.","title":"OpenSource"},{"location":"#getting-started","text":"in order to get started with developing or using the code head over to Setup","title":"Getting started"},{"location":"core/","text":"ESP IoT Core introduction Purpose The intention of the core functionallity is to simplify the development of ESP32 IoT Devices, which interact with AWS Services. Core Classes EspConfig EspLogger EspSpiffs EspWifi EspMqtt EspConnectionHandler EspScheduler EspSensor EspNTP EspJson EspComponent Keys Scripts","title":"Introduction"},{"location":"core/#esp-iot-core-introduction","text":"","title":"ESP IoT Core introduction"},{"location":"core/#purpose","text":"The intention of the core functionallity is to simplify the development of ESP32 IoT Devices, which interact with AWS Services.","title":"Purpose"},{"location":"core/#core-classes","text":"EspConfig EspLogger EspSpiffs EspWifi EspMqtt EspConnectionHandler EspScheduler EspSensor EspNTP EspJson EspComponent Keys","title":"Core Classes"},{"location":"core/#scripts","text":"","title":"Scripts"},{"location":"core/core_classes/esp_config/","text":"Configuration Purpose The aim of the implemented configuration is to write settings like wifi name and password to a separate configuration file instead of hard coding them in the source code. This gives the user the advantage of being able to change settings without having to change or re-flash the source code. Actually the following settings are implemented into the config. wifi ssid wifi password aws url aws port mqtt subsribe topic mqtt publish topic device id device position logger level logger output level Implementation Create Config file To create the configuration file the python script generate_config.py is used. This script must be called from a command line, and the settings are then entered from the command line as well. Then a file called config_file.json is created automatically and stored in a directory with the name data. The created configuration file is of the type json . This format is commonly used in IoT applications for data exchange. In a json file the data is stored as text in a ordered way. This makes it easy to create, edit and read these files. Upload Config On the ESP device the configuration file is stored in the SPIFFS file system together with the certificates for the ssl connection. To upload the configuration we suggest to use PlatformIO but you are also free to use a other option like the Ardunio-IDE . The upload process is described here . EspConfig Class The Esp_Config class is used on the ESP to read the configuration file from SPIFFS and to make the its contents available through get....() functions. The class is implemented as singelton. Therefore the normal way to get an object of the class is to call getInstance() and then a pointer to the object will be returned. To read the config file you have to call only once the readConfig() function of the EspConfig object. This class uses the class Esp_Spiffs to read the SPIFFS and the library ArduinoJson.h to parse the json file.","title":"Config"},{"location":"core/core_classes/esp_config/#configuration","text":"","title":"Configuration"},{"location":"core/core_classes/esp_config/#purpose","text":"The aim of the implemented configuration is to write settings like wifi name and password to a separate configuration file instead of hard coding them in the source code. This gives the user the advantage of being able to change settings without having to change or re-flash the source code. Actually the following settings are implemented into the config. wifi ssid wifi password aws url aws port mqtt subsribe topic mqtt publish topic device id device position logger level logger output level","title":"Purpose"},{"location":"core/core_classes/esp_config/#implementation","text":"","title":"Implementation"},{"location":"core/core_classes/esp_config/#create-config-file","text":"To create the configuration file the python script generate_config.py is used. This script must be called from a command line, and the settings are then entered from the command line as well. Then a file called config_file.json is created automatically and stored in a directory with the name data. The created configuration file is of the type json . This format is commonly used in IoT applications for data exchange. In a json file the data is stored as text in a ordered way. This makes it easy to create, edit and read these files.","title":"Create Config file"},{"location":"core/core_classes/esp_config/#upload-config","text":"On the ESP device the configuration file is stored in the SPIFFS file system together with the certificates for the ssl connection. To upload the configuration we suggest to use PlatformIO but you are also free to use a other option like the Ardunio-IDE . The upload process is described here .","title":"Upload Config"},{"location":"core/core_classes/esp_config/#espconfig-class","text":"The Esp_Config class is used on the ESP to read the configuration file from SPIFFS and to make the its contents available through get....() functions. The class is implemented as singelton. Therefore the normal way to get an object of the class is to call getInstance() and then a pointer to the object will be returned. To read the config file you have to call only once the readConfig() function of the EspConfig object. This class uses the class Esp_Spiffs to read the SPIFFS and the library ArduinoJson.h to parse the json file.","title":"EspConfig Class"},{"location":"core/core_classes/esp_connection_handler/","text":"Purpose Implementation","title":"Connection Handler"},{"location":"core/core_classes/esp_connection_handler/#purpose","text":"","title":"Purpose"},{"location":"core/core_classes/esp_connection_handler/#implementation","text":"","title":"Implementation"},{"location":"core/core_classes/esp_keys/","text":"Keys and Certificates Why do we need a key and certificate files? To establish a TLS connection with device authentification the following three files are necessary: Privat Key (/esp32-d1mini-01.private.key) Device Certificate (/esp32-d1mini-01.cert.crt) Root Certificate (/root-CA.pem) You get these files from AWS and the process is described here. These three files are stored on the SPIFFS . To store them in the file system you just have to put the files together with the config file into the data directory and then follow the upload process which is described here . Attention It is important that the files have exactly the same name as seen in the brackets above. Keys Class The purpose of this class is to read the three files from the file system and make them accessible by get...() functions. The files are read by calling the begin() function of the class. The class uses the EspSpiffs class to read from the file system.","title":"Keys"},{"location":"core/core_classes/esp_keys/#keys-and-certificates","text":"","title":"Keys and Certificates"},{"location":"core/core_classes/esp_keys/#why-do-we-need-a-key-and-certificate-files","text":"To establish a TLS connection with device authentification the following three files are necessary: Privat Key (/esp32-d1mini-01.private.key) Device Certificate (/esp32-d1mini-01.cert.crt) Root Certificate (/root-CA.pem) You get these files from AWS and the process is described here. These three files are stored on the SPIFFS . To store them in the file system you just have to put the files together with the config file into the data directory and then follow the upload process which is described here . Attention It is important that the files have exactly the same name as seen in the brackets above.","title":"Why do we need a key and certificate files?"},{"location":"core/core_classes/esp_keys/#keys-class","text":"The purpose of this class is to read the three files from the file system and make them accessible by get...() functions. The files are read by calling the begin() function of the class. The class uses the EspSpiffs class to read from the file system.","title":"Keys Class"},{"location":"core/core_classes/esp_logger/","text":"Logger Purpose The purpose of the logger is to log messages with different log levels such as info, debug in a file on the SPIFFS and print the information either at the beginning of the program via the serial monitor or directly during the program, depending on the configuration The aim of these is to inform the user about the device status and to simplify and speed up debugging. Implementation The configuration described below is passed to the program via the config file . Log levels For the logging one of the following log levels can be selected: LOG_LEVEL_OFF No logging. LOG_LEVEL_FATAL Designates very severe error events that will presumably lead the application to abort. LOG_LEVEL_ERROR Designates error events that might still allow the application to continue running. LOG_LEVEL_WARNING Designates potentially harmful situations. LOG_LEVEL_INFO Designates informational messages that highlight the progress of the application at coarse-grained level. LOG_LEVEL_DEBUG Designates fine-grained informational events that are most useful to debug an application. Note For example, if INFO is selected, WARNING, ERROR and FATAL messages will still be logged, but DEBUG messages will not. This is how the levels work. Logging For the output one of the following options can be selected: LOG_OUTPUT_SERIAL_DIRECT 0 Logging events are directly printed over serial interface when they occure. LOG_OUTPUT_SERIAL_BEGIN 1 Logging events are stored in the SPIFFS and printed over the serial interface at the start of the program. LOG_OUTPUT_SERIAL_DIRECT_BEGIN 2 Combination of LOG_OUTPUT_SERIAL_DIRECT and LOG_OUTPUT_SERIAL_BEGIN. LOG_OUTPUT_OFF 3 Not output at all. Log file storage The logged information is stored in three files on the SPIFFS. Each has a length of 100 lines. This is determined by the LOG_FILE_MAX_ROWS definition. This limits the logging to a total of 300 messages with the purpose of preventing Flash from becoming completely full if the program runs for a very long time. When all three files are full, the logger starts again with the first file and overwrites it. EspLogger These class implements the functionality described above. The class is implemented as singelton. Therefore the normal way to get an object of the class is to call getInstance() and then a pointer to the object will be returned. By calling logBegin(log_level, log_output_level) the logger is initialized and the logged messages from the last program call is depending on the log_output_level printed to the serial monitor. The parameters log_level and log_output_level are stored in the configuration file and can be accessed using the Esp_Config class. In your code you can call on of the following functions to log a message with a specific log level. logFatal(message); logError(message); logWarning(message); logInfo(message); logDebug(message); Note The logger automatically adds an appropriate label and timestamp to your message. This means that you only have to worry about the content of the message and the logger takes care of the rest. The class uses the EspSpiffs to access SPIFFS and the Ntp class to get the current time.","title":"Logger"},{"location":"core/core_classes/esp_logger/#logger","text":"","title":"Logger"},{"location":"core/core_classes/esp_logger/#purpose","text":"The purpose of the logger is to log messages with different log levels such as info, debug in a file on the SPIFFS and print the information either at the beginning of the program via the serial monitor or directly during the program, depending on the configuration The aim of these is to inform the user about the device status and to simplify and speed up debugging.","title":"Purpose"},{"location":"core/core_classes/esp_logger/#implementation","text":"The configuration described below is passed to the program via the config file .","title":"Implementation"},{"location":"core/core_classes/esp_logger/#log-levels","text":"For the logging one of the following log levels can be selected: LOG_LEVEL_OFF No logging. LOG_LEVEL_FATAL Designates very severe error events that will presumably lead the application to abort. LOG_LEVEL_ERROR Designates error events that might still allow the application to continue running. LOG_LEVEL_WARNING Designates potentially harmful situations. LOG_LEVEL_INFO Designates informational messages that highlight the progress of the application at coarse-grained level. LOG_LEVEL_DEBUG Designates fine-grained informational events that are most useful to debug an application. Note For example, if INFO is selected, WARNING, ERROR and FATAL messages will still be logged, but DEBUG messages will not. This is how the levels work.","title":"Log levels"},{"location":"core/core_classes/esp_logger/#logging","text":"For the output one of the following options can be selected: LOG_OUTPUT_SERIAL_DIRECT 0 Logging events are directly printed over serial interface when they occure. LOG_OUTPUT_SERIAL_BEGIN 1 Logging events are stored in the SPIFFS and printed over the serial interface at the start of the program. LOG_OUTPUT_SERIAL_DIRECT_BEGIN 2 Combination of LOG_OUTPUT_SERIAL_DIRECT and LOG_OUTPUT_SERIAL_BEGIN. LOG_OUTPUT_OFF 3 Not output at all.","title":"Logging"},{"location":"core/core_classes/esp_logger/#log-file-storage","text":"The logged information is stored in three files on the SPIFFS. Each has a length of 100 lines. This is determined by the LOG_FILE_MAX_ROWS definition. This limits the logging to a total of 300 messages with the purpose of preventing Flash from becoming completely full if the program runs for a very long time. When all three files are full, the logger starts again with the first file and overwrites it.","title":"Log file storage"},{"location":"core/core_classes/esp_logger/#esplogger","text":"These class implements the functionality described above. The class is implemented as singelton. Therefore the normal way to get an object of the class is to call getInstance() and then a pointer to the object will be returned. By calling logBegin(log_level, log_output_level) the logger is initialized and the logged messages from the last program call is depending on the log_output_level printed to the serial monitor. The parameters log_level and log_output_level are stored in the configuration file and can be accessed using the Esp_Config class. In your code you can call on of the following functions to log a message with a specific log level. logFatal(message); logError(message); logWarning(message); logInfo(message); logDebug(message); Note The logger automatically adds an appropriate label and timestamp to your message. This means that you only have to worry about the content of the message and the logger takes care of the rest. The class uses the EspSpiffs to access SPIFFS and the Ntp class to get the current time.","title":"EspLogger"},{"location":"core/core_classes/esp_spiffs/","text":"SPIFFS Description SPIFFS (Serial Peripheral Interface Flash File System) is a simple file system which is located on the ESP flash storage. The advantage of the file system is that we can change the configuration and tls certificate files independently of the source code. Uploade to SPIFFS To uplode the SPIFFS we suggest to use PlatformIO but you are also free to use a other option like the Ardunio-IDE . How To uploade the SPIFFS with PlatformIO Connect your ESP to your computer using a USB cable. In VS Code, open the PlatformIO extension on the left side and then open the esp device folder under PROJECT TASKS . Click on Build Filesystem Image and wait unitl the task finishes. This is indicated when SUCCESS is printed at the terminal. What happens is that the content in the top directory data is used to build a spiffs image. Click on Upload Filesystem Image . Now the previously build image is uploaded to the flash storage of the connected ESP. EspSpiffs class The EspSpiffs class is used to read the SPIFFS on the ESP in a structured way. The class is used by the other classes Keys ,Esp_Config and Esp_Logger. This class uses the library SPIFFS.h from Espressif. It is described here .","title":"Spiffs"},{"location":"core/core_classes/esp_spiffs/#spiffs","text":"","title":"SPIFFS"},{"location":"core/core_classes/esp_spiffs/#description","text":"SPIFFS (Serial Peripheral Interface Flash File System) is a simple file system which is located on the ESP flash storage. The advantage of the file system is that we can change the configuration and tls certificate files independently of the source code.","title":"Description"},{"location":"core/core_classes/esp_spiffs/#uploade-to-spiffs","text":"To uplode the SPIFFS we suggest to use PlatformIO but you are also free to use a other option like the Ardunio-IDE . How To uploade the SPIFFS with PlatformIO Connect your ESP to your computer using a USB cable. In VS Code, open the PlatformIO extension on the left side and then open the esp device folder under PROJECT TASKS . Click on Build Filesystem Image and wait unitl the task finishes. This is indicated when SUCCESS is printed at the terminal. What happens is that the content in the top directory data is used to build a spiffs image. Click on Upload Filesystem Image . Now the previously build image is uploaded to the flash storage of the connected ESP.","title":"Uploade to SPIFFS"},{"location":"core/core_classes/esp_spiffs/#espspiffs-class","text":"The EspSpiffs class is used to read the SPIFFS on the ESP in a structured way. The class is used by the other classes Keys ,Esp_Config and Esp_Logger. This class uses the library SPIFFS.h from Espressif. It is described here .","title":"EspSpiffs class"},{"location":"core/core_classes/esp_wifi/","text":"EspWifi Class Purpose The aim of this class is to bundle the functionality for structured access to the WLAN connection in one class. This ensures that the WLAN connection is always accessed in the same way which helps to avoid errors. The is used in the connection handler- The class uses the WiFi.h library from the Arduino ESP Core. How to use? For a intial wifi connection the function beginWifi(ssid, password) has to be called. The function passes the parameters ssid and password. These parameters are stored in the configuration file and can be accessed using the Esp_Config class.The current WLAN status can be checked with statusWifi() and the connection can be re-established with reconnectWifi().","title":"Wifi"},{"location":"core/core_classes/esp_wifi/#espwifi-class","text":"","title":"EspWifi Class"},{"location":"core/core_classes/esp_wifi/#purpose","text":"The aim of this class is to bundle the functionality for structured access to the WLAN connection in one class. This ensures that the WLAN connection is always accessed in the same way which helps to avoid errors. The is used in the connection handler- The class uses the WiFi.h library from the Arduino ESP Core.","title":"Purpose"},{"location":"core/core_classes/esp_wifi/#how-to-use","text":"For a intial wifi connection the function beginWifi(ssid, password) has to be called. The function passes the parameters ssid and password. These parameters are stored in the configuration file and can be accessed using the Esp_Config class.The current WLAN status can be checked with statusWifi() and the connection can be re-established with reconnectWifi().","title":"How to use?"},{"location":"sensors/","text":"Sensors","title":"Introduction"},{"location":"sensors/#sensors","text":"","title":"Sensors"},{"location":"setup/documentation/","text":"Documentation The documentation is generated by MkDocs with the Material for MkDocs Theme. MkDocs is a static site generator wich uses Markdown as markup language. For a Markdown cheat sheet click here . Local build Use the following command to build a local instance: mkdocs serve The documentation can be accessed on the local address shown in the terminal ( http://localhost:8000 ) Hint mkdocs handles updates of your .md code automatically. You don't need to run the command twice when updates are made. Assuming you are still in the same session Deploy When the documentation is ready it can be uploaded to GitHub using: mkdocs gh-deploy This will automatically build an upload the site to GitHub using the branch gh-pages . Warning Please avoid modifying the branch gh-pages manually. Useful Commands Diagrams Diagrams can be created by using mermaid . Mermaid can be used by creating a code-block with the mermaid language tag. ```mermaid <your diagram> ```","title":"Documentation"},{"location":"setup/documentation/#documentation","text":"The documentation is generated by MkDocs with the Material for MkDocs Theme. MkDocs is a static site generator wich uses Markdown as markup language. For a Markdown cheat sheet click here .","title":"Documentation"},{"location":"setup/documentation/#local-build","text":"Use the following command to build a local instance: mkdocs serve The documentation can be accessed on the local address shown in the terminal ( http://localhost:8000 ) Hint mkdocs handles updates of your .md code automatically. You don't need to run the command twice when updates are made. Assuming you are still in the same session","title":"Local build"},{"location":"setup/documentation/#deploy","text":"When the documentation is ready it can be uploaded to GitHub using: mkdocs gh-deploy This will automatically build an upload the site to GitHub using the branch gh-pages . Warning Please avoid modifying the branch gh-pages manually.","title":"Deploy"},{"location":"setup/documentation/#useful-commands","text":"","title":"Useful Commands"},{"location":"setup/documentation/#diagrams","text":"Diagrams can be created by using mermaid . Mermaid can be used by creating a code-block with the mermaid language tag. ```mermaid <your diagram> ```","title":"Diagrams"},{"location":"setup/setup/","text":"Getting started First steps Requirements Make sure that python 3.8 or higher and pip3 are installed on your PC. Next ensure that you have installed a capable text editor like VS Code (any other editor should work fine as long a you can use the necessary plugins for this project). Note If your are using VS Code you can install some very helpful extensions . Those extension are optional but will simplify writing code. Check out the extensions tab further below. Dependencies The project requires some python packages which are essential f.e. for embedded development (PlatformIO) or for building docs (Mkdocs). You can install them by using pip3 . Make sure that you are in the projects root folder Linux / macOS Windows pip3 install -r requirements.txt python3 -m pip install -r requirements.txt After the installation you should be able to use mkdocs and pio , which are the CLI tools for the documentation and platformIO. Hint For more information about mkdocs head to Documentation Extensions This list contains some good extensions which make developing code way easier. As always, this is just a short summary of what's possible. If you want to dig deeper into Extensions and Tools for VS Code, visit their docs . PlatformIO C++ C++ Extension Pack C/C++ Themes Python Pylance Mkdocs","title":"Getting Started"},{"location":"setup/setup/#getting-started","text":"","title":"Getting started"},{"location":"setup/setup/#first-steps","text":"","title":"First steps"},{"location":"setup/setup/#requirements","text":"Make sure that python 3.8 or higher and pip3 are installed on your PC. Next ensure that you have installed a capable text editor like VS Code (any other editor should work fine as long a you can use the necessary plugins for this project). Note If your are using VS Code you can install some very helpful extensions . Those extension are optional but will simplify writing code. Check out the extensions tab further below.","title":"Requirements"},{"location":"setup/setup/#dependencies","text":"The project requires some python packages which are essential f.e. for embedded development (PlatformIO) or for building docs (Mkdocs). You can install them by using pip3 . Make sure that you are in the projects root folder Linux / macOS Windows pip3 install -r requirements.txt python3 -m pip install -r requirements.txt After the installation you should be able to use mkdocs and pio , which are the CLI tools for the documentation and platformIO. Hint For more information about mkdocs head to Documentation","title":"Dependencies"},{"location":"setup/setup/#extensions","text":"This list contains some good extensions which make developing code way easier. As always, this is just a short summary of what's possible. If you want to dig deeper into Extensions and Tools for VS Code, visit their docs . PlatformIO C++ C++ Extension Pack C/C++ Themes Python Pylance Mkdocs","title":"Extensions"},{"location":"setup/structure/","text":"Structure This repository combines the source code, the documentation and the editor setup at once. Therefore it is crucial to understand the directories structure. The following folders are most likely to be changed by future developers: /src Here all every line of C++ code is put. Within this directory there are sub-folders in order to keep a tidy structure. When adding a new folder for a new structural element, give this folder a meaningful name. /scripts This folders intention is to store essential scripts which facilitate coding. Therefore all types of scripts can be put here ( python , shell etc.). /docs The /docs folder (like the name implies) stores every line of markdown code. In the future the intention of this project is to integrate a automatic doc generation tool like Doxygen . Doxygen allows the developer to write doc-strings which can be compiled into readable markdown code.","title":"Structure"},{"location":"setup/structure/#structure","text":"This repository combines the source code, the documentation and the editor setup at once. Therefore it is crucial to understand the directories structure. The following folders are most likely to be changed by future developers:","title":"Structure"},{"location":"setup/structure/#src","text":"Here all every line of C++ code is put. Within this directory there are sub-folders in order to keep a tidy structure. When adding a new folder for a new structural element, give this folder a meaningful name.","title":"/src"},{"location":"setup/structure/#scripts","text":"This folders intention is to store essential scripts which facilitate coding. Therefore all types of scripts can be put here ( python , shell etc.).","title":"/scripts"},{"location":"setup/structure/#docs","text":"The /docs folder (like the name implies) stores every line of markdown code. In the future the intention of this project is to integrate a automatic doc generation tool like Doxygen . Doxygen allows the developer to write doc-strings which can be compiled into readable markdown code.","title":"/docs"},{"location":"setup/coding-style/cpp/","text":"C++ coding style Next to consistency as a main aspect of good code, the second most important aspect is a certain style which the average c++ programmer is capable to read and understand properly. Therefore the following documents states the essential naming conventions. Hint Here is a link for a more detailed dive into `c++ core guidelines' Style guide by the Barr Group: Style Guide Naming conventions Variables The name of a variable should be as accurate as possible and as short as possible at the same time. Example: // don't int x ; x = 10 + 5 ; // do int sum sum = 10 + 5 ; A variable can be used in two different scenarios. Global/Local variables Global/Local variables should be defined in a snake_case style. Example: int global_variable ; Private variables Private variables should be defined the same way as global variables. The main difference for private variables is a defined prefix _ . Example: int _private_variable ; Constants & Preprocessor Values Constants are expression with a fixed value. They are defined with the key `const. The naming convention for constants and preprocessor values prescribes that all letters are upper case letters with snake case subdivision Example: const int PI_VALUE = 3.14159 ; Functions A function is a block of code which runs when it's called. Data in form of parameters can be passed into a function. Functions can be written as non-returning and returning type. Functions should start with a lower case letter. The following word should be upper case . This method is called camelCase Example: void exampleFunktion () { // do some stuff } Classes (Types, Template parameters) C++ is a object-oriented programming language. Therefore it's all about creating objects which contain both data and functions for a certain task. In the example picture shown above, there is the class car defined, which has certain methods and attributes . This class can be used to create different objects which share the same set of properties with different values. A class should be defined with all upper case (PascalCase) notation. Example: class Car { public : string brand ; int max_speed ; int power ; Car ( string ini_brand , int ini_speed , ini_power ) { brand = ini_brand ; max_speed = ini_speed ; power = ini_power ; } private : int _current_speed ; }; void GeneralCar::setSpeed ( int new_speed ) { _current_speed = new_speed ; } int main () { // declaration of two objects Car car1 ( \"Auto1\" , 200 , 100 ); Car car2 ( \"Auto2\" , 300 , 200 ); //setting the speed car1 . setSpeed ( 250 ); return 0 ; } Braces In order to get a clear structure the following braces scheme should be taking into account when programming. Every left brace ( { ) should be appear by itself on the line below it the block it opens. The corresponding right brace ( } ) should be placed by itself in the same position th appropriate number of lines later in the file. Example if ( car . speed == \"fast\" ) { car . price = \"high\" ; } else { car . price = \"low\" ; } The indentation should always be made with a tab . For every hierarchy step one tab has to be added. Example if ( car . speed == \"fast\" ) { car . price = \"high\" ; if ( car . weight >= 1000 ) { car . type = \"Truck\" ; } } else { car . price = \"low\" ; } Comments If the section of code is not clearly understandable there should be a short description of the current function in form of a comment. For commenting block // should be used. Warning Inline comments should be used with caution, because they can cause chaotic code. Example DON'T // divides up two double values double division ( double dividend , double divisor ) { // this is the result variable double div ; // the result is calculated here: div = dividend / divisor ; // here the result is given back return div ; }","title":"C++"},{"location":"setup/coding-style/cpp/#c-coding-style","text":"Next to consistency as a main aspect of good code, the second most important aspect is a certain style which the average c++ programmer is capable to read and understand properly. Therefore the following documents states the essential naming conventions. Hint Here is a link for a more detailed dive into `c++ core guidelines' Style guide by the Barr Group: Style Guide","title":"C++ coding style"},{"location":"setup/coding-style/cpp/#naming-conventions","text":"","title":"Naming conventions"},{"location":"setup/coding-style/cpp/#variables","text":"The name of a variable should be as accurate as possible and as short as possible at the same time. Example: // don't int x ; x = 10 + 5 ; // do int sum sum = 10 + 5 ; A variable can be used in two different scenarios. Global/Local variables Global/Local variables should be defined in a snake_case style. Example: int global_variable ; Private variables Private variables should be defined the same way as global variables. The main difference for private variables is a defined prefix _ . Example: int _private_variable ;","title":"Variables"},{"location":"setup/coding-style/cpp/#constants-preprocessor-values","text":"Constants are expression with a fixed value. They are defined with the key `const. The naming convention for constants and preprocessor values prescribes that all letters are upper case letters with snake case subdivision Example: const int PI_VALUE = 3.14159 ;","title":"Constants &amp; Preprocessor Values"},{"location":"setup/coding-style/cpp/#functions","text":"A function is a block of code which runs when it's called. Data in form of parameters can be passed into a function. Functions can be written as non-returning and returning type. Functions should start with a lower case letter. The following word should be upper case . This method is called camelCase Example: void exampleFunktion () { // do some stuff }","title":"Functions"},{"location":"setup/coding-style/cpp/#classes-types-template-parameters","text":"C++ is a object-oriented programming language. Therefore it's all about creating objects which contain both data and functions for a certain task. In the example picture shown above, there is the class car defined, which has certain methods and attributes . This class can be used to create different objects which share the same set of properties with different values. A class should be defined with all upper case (PascalCase) notation. Example: class Car { public : string brand ; int max_speed ; int power ; Car ( string ini_brand , int ini_speed , ini_power ) { brand = ini_brand ; max_speed = ini_speed ; power = ini_power ; } private : int _current_speed ; }; void GeneralCar::setSpeed ( int new_speed ) { _current_speed = new_speed ; } int main () { // declaration of two objects Car car1 ( \"Auto1\" , 200 , 100 ); Car car2 ( \"Auto2\" , 300 , 200 ); //setting the speed car1 . setSpeed ( 250 ); return 0 ; }","title":"Classes (Types, Template parameters)"},{"location":"setup/coding-style/cpp/#braces","text":"In order to get a clear structure the following braces scheme should be taking into account when programming. Every left brace ( { ) should be appear by itself on the line below it the block it opens. The corresponding right brace ( } ) should be placed by itself in the same position th appropriate number of lines later in the file. Example if ( car . speed == \"fast\" ) { car . price = \"high\" ; } else { car . price = \"low\" ; } The indentation should always be made with a tab . For every hierarchy step one tab has to be added. Example if ( car . speed == \"fast\" ) { car . price = \"high\" ; if ( car . weight >= 1000 ) { car . type = \"Truck\" ; } } else { car . price = \"low\" ; }","title":"Braces"},{"location":"setup/coding-style/cpp/#comments","text":"If the section of code is not clearly understandable there should be a short description of the current function in form of a comment. For commenting block // should be used. Warning Inline comments should be used with caution, because they can cause chaotic code. Example DON'T // divides up two double values double division ( double dividend , double divisor ) { // this is the result variable double div ; // the result is calculated here: div = dividend / divisor ; // here the result is given back return div ; }","title":"Comments"},{"location":"setup/coding-style/git/","text":"Branching System Commit Style In order to achieve a uniform naming for commit messages the following commit style should be used when creating a new commit message. Keyword Description ADD Is used if there is a new change in the code. f.e git commit -m \"ADD function XY()\" FIX Used for minor changes, bugfixes of an already existing part of the code. f.e git commit -m \"FIX functionality of XY\" REF Written short for: REFACTOR. Is used when there is a major change in multiple code-segments and the structure of the code is reworked. f.e git commit -m \"UPDATE setup of analog sensors\" Creating Pull Requests In order to keep the master branch clean and functioning the prototyping repository has a branch protection rule . When someone wants to merge code onto the master branche a pull request has to be made. The pull request informs the admin of the repository to have a look over the code in order to approve if this its functioning and good code which can be merged without hesitation. In order to understand how to create a pull request have a look here source: https://codeburst.io/git-and-github-in-a-nutshell-b0a3cc06458f \u21a9","title":"Git"},{"location":"setup/coding-style/git/#branching-system","text":"","title":"Branching System"},{"location":"setup/coding-style/git/#commit-style","text":"In order to achieve a uniform naming for commit messages the following commit style should be used when creating a new commit message. Keyword Description ADD Is used if there is a new change in the code. f.e git commit -m \"ADD function XY()\" FIX Used for minor changes, bugfixes of an already existing part of the code. f.e git commit -m \"FIX functionality of XY\" REF Written short for: REFACTOR. Is used when there is a major change in multiple code-segments and the structure of the code is reworked. f.e git commit -m \"UPDATE setup of analog sensors\"","title":"Commit Style"},{"location":"setup/coding-style/git/#creating-pull-requests","text":"In order to keep the master branch clean and functioning the prototyping repository has a branch protection rule . When someone wants to merge code onto the master branche a pull request has to be made. The pull request informs the admin of the repository to have a look over the code in order to approve if this its functioning and good code which can be merged without hesitation. In order to understand how to create a pull request have a look here source: https://codeburst.io/git-and-github-in-a-nutshell-b0a3cc06458f \u21a9","title":"Creating Pull Requests"},{"location":"software-planning/connection-handler/","text":"Class - ConnectionHandler The purpose of this class is to ensure that every remote connection is alive and maintained (Wifi, MQTT to broker). Features The main structure contains a state machine which handles the connection to the Wifi, sets up a TLS client for MQTT, enables a connection to the AWS MQTT Broker. Structure Basic UML in order to understand the structure of the class classDiagram class ConnectionHandler{ +ESPWifi esp_wifi +ESPLogger esp_logger +EspConfig *esp_config +MQTTClient *mqtt_client +enum states -ConnectionHandler() -state connectionStateMachine() }","title":"Class - ConnectionHandler"},{"location":"software-planning/connection-handler/#class-connectionhandler","text":"The purpose of this class is to ensure that every remote connection is alive and maintained (Wifi, MQTT to broker).","title":"Class - ConnectionHandler"},{"location":"software-planning/connection-handler/#features","text":"The main structure contains a state machine which handles the connection to the Wifi, sets up a TLS client for MQTT, enables a connection to the AWS MQTT Broker.","title":"Features"},{"location":"software-planning/connection-handler/#structure","text":"Basic UML in order to understand the structure of the class classDiagram class ConnectionHandler{ +ESPWifi esp_wifi +ESPLogger esp_logger +EspConfig *esp_config +MQTTClient *mqtt_client +enum states -ConnectionHandler() -state connectionStateMachine() }","title":"Structure"},{"location":"software-planning/sensors/","text":"Structure for implementing Sensor Modules A sensor module is a a type of measuring device which can be attached to the ESP32 via a serial connection (I2C, 1WIRE). The sensors of the module measures physical quantities like temperature or humidity, etc. In order to get a general form for adding new sensor modules to the framework the following points should be taken into account: A newly written class for a sensor module should always implement the EspComponent superclass. That is necessary to ensure a general structure when calling the new sensor modules object. The measured physical values which can be read of the sensor should be fed into a new instance of the sensor class. Structure Basic UML in order to understand the structure. The implemented sensor module DHT22 is just an example. classDiagram class EspComponent{ -void setup() -void setup(T setup_config) -void update() -void setValue() } class Sensor { +float sensor_value -char* sensor_type -char* unit -char* mqtt_topic -Sensor(char* sensor_type, char* mqtt_topic) -void setValue(float sensor_value) -void updateValue() } class DHT22 { -Sensor temperature -Sensor humidity -void setup() -void setValue() -void update() } EspComponent < |-- DHT22 Sensor --> DHT22 : contains","title":"Structure for implementing Sensor Modules"},{"location":"software-planning/sensors/#structure-for-implementing-sensor-modules","text":"A sensor module is a a type of measuring device which can be attached to the ESP32 via a serial connection (I2C, 1WIRE). The sensors of the module measures physical quantities like temperature or humidity, etc. In order to get a general form for adding new sensor modules to the framework the following points should be taken into account: A newly written class for a sensor module should always implement the EspComponent superclass. That is necessary to ensure a general structure when calling the new sensor modules object. The measured physical values which can be read of the sensor should be fed into a new instance of the sensor class.","title":"Structure for implementing Sensor Modules"},{"location":"software-planning/sensors/#structure","text":"Basic UML in order to understand the structure. The implemented sensor module DHT22 is just an example. classDiagram class EspComponent{ -void setup() -void setup(T setup_config) -void update() -void setValue() } class Sensor { +float sensor_value -char* sensor_type -char* unit -char* mqtt_topic -Sensor(char* sensor_type, char* mqtt_topic) -void setValue(float sensor_value) -void updateValue() } class DHT22 { -Sensor temperature -Sensor humidity -void setup() -void setValue() -void update() } EspComponent < |-- DHT22 Sensor --> DHT22 : contains","title":"Structure"}]}