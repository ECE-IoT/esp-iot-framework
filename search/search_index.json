{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ESP IoT Framework This frameworks intention is to simplify the development of ESP32 IoT Devices, which interact with AWS Services. The framework is complemented by the AWS IoT Framework Motivation Overview The networking of sensors and actuators via the internet is becoming increasingly important in industry, but also in the private sector. In this project work it will be shown how a processing chain from the sensor to the cloud service (AWS) can be realized practically. The project aims to provide a valuable overview of what is possible with embedded/connected IoT devices that can transmit data to the cloud. In addition, the projects goal was to provide a secure connection to AWS. Attention Please be aware that this project is a feasibility study. It does not provide code which is ready for production, or similar. Further information about the future intentions of this project can be found here. OpenSource This project can be accessed via the MIT License. Based upon this license the project team highly encourages people who are keen on getting in touch with embedded IoT applications to contribute to this project. Getting started in order to get started with developing or using the code head over to Setup","title":"ESP IoT Framework"},{"location":"#esp-iot-framework","text":"This frameworks intention is to simplify the development of ESP32 IoT Devices, which interact with AWS Services. The framework is complemented by the AWS IoT Framework","title":"ESP IoT Framework"},{"location":"#motivation","text":"","title":"Motivation"},{"location":"#overview","text":"The networking of sensors and actuators via the internet is becoming increasingly important in industry, but also in the private sector. In this project work it will be shown how a processing chain from the sensor to the cloud service (AWS) can be realized practically. The project aims to provide a valuable overview of what is possible with embedded/connected IoT devices that can transmit data to the cloud. In addition, the projects goal was to provide a secure connection to AWS. Attention Please be aware that this project is a feasibility study. It does not provide code which is ready for production, or similar. Further information about the future intentions of this project can be found here.","title":"Overview"},{"location":"#opensource","text":"This project can be accessed via the MIT License. Based upon this license the project team highly encourages people who are keen on getting in touch with embedded IoT applications to contribute to this project.","title":"OpenSource"},{"location":"#getting-started","text":"in order to get started with developing or using the code head over to Setup","title":"Getting started"},{"location":"core/","text":"ESP IoT Core introduction Purpose The intention of the core functionallity is to simplify the development of ESP32 IoT Devices, which interact with AWS Services. Core Classes EspConfig EspLogger EspSpiffs EspWifi EspMqtt EspConnectionHandler EspScheduler EspSensor EspNTP EspJson EspComponent Keys Scripts","title":"Introduction"},{"location":"core/#esp-iot-core-introduction","text":"","title":"ESP IoT Core introduction"},{"location":"core/#purpose","text":"The intention of the core functionallity is to simplify the development of ESP32 IoT Devices, which interact with AWS Services.","title":"Purpose"},{"location":"core/#core-classes","text":"EspConfig EspLogger EspSpiffs EspWifi EspMqtt EspConnectionHandler EspScheduler EspSensor EspNTP EspJson EspComponent Keys","title":"Core Classes"},{"location":"core/#scripts","text":"","title":"Scripts"},{"location":"core/core_classes/esp_config/","text":"Configuration Purpose The aim of the implemented configuration is to write settings like wifi name and password to a separate configuration file instead of hard coding them in the source code. This gives the user the advantage of being able to change settings without having to change or re-flash the source code. Actually the following settings are implemented into the config. wifi ssid wifi password aws url aws port mqtt subsribe topic mqtt publish topic device id device position logger level logger output level Implementation Create Config file To create the configuration file the python script genreate_config.py is used. This script must be called from a command line, and the settings are then entered from the command line as well. Then a file called config_file.json is created atomatically and stored in a directory with the name data. The created configuration file is of the type json . This format is commonly used in IoT applications for data exchange. In a json file the data is stored as text in a ordered way. This makes it easy to create, edit and read these files. Upload Config On the ESP device the configuration file is stored in the SPIFFS file system together with the certificates for the ssl connection. To upload the configuration we suggest to use PlatformIO but you are also free to use a other option like the Ardunio-IDE . The upload process is described here . EspConfig Class The Esp_Config class is used on the ESP to read the configuration file from SPIFFS and to make the its contents available through getFkt() functions. The class is implemented as singelton. Therefore the normal way to get an object of the class is to call getInstance() and then a pointer to the object will be returned. To read the config file you have to call only once the readConfig() function of the EspConfig object. Attention It is important to call readConfig() at the beginning in Arduinos Setup() because other functionallitys like EspConenctionHandler use the class in there implementations. This class uses the class Esp_Spiffs to read the SPIFFS and the library ArduinoJson.h to parse the json file.","title":"Config"},{"location":"core/core_classes/esp_config/#configuration","text":"","title":"Configuration"},{"location":"core/core_classes/esp_config/#purpose","text":"The aim of the implemented configuration is to write settings like wifi name and password to a separate configuration file instead of hard coding them in the source code. This gives the user the advantage of being able to change settings without having to change or re-flash the source code. Actually the following settings are implemented into the config. wifi ssid wifi password aws url aws port mqtt subsribe topic mqtt publish topic device id device position logger level logger output level","title":"Purpose"},{"location":"core/core_classes/esp_config/#implementation","text":"","title":"Implementation"},{"location":"core/core_classes/esp_config/#create-config-file","text":"To create the configuration file the python script genreate_config.py is used. This script must be called from a command line, and the settings are then entered from the command line as well. Then a file called config_file.json is created atomatically and stored in a directory with the name data. The created configuration file is of the type json . This format is commonly used in IoT applications for data exchange. In a json file the data is stored as text in a ordered way. This makes it easy to create, edit and read these files.","title":"Create Config file"},{"location":"core/core_classes/esp_config/#upload-config","text":"On the ESP device the configuration file is stored in the SPIFFS file system together with the certificates for the ssl connection. To upload the configuration we suggest to use PlatformIO but you are also free to use a other option like the Ardunio-IDE . The upload process is described here .","title":"Upload Config"},{"location":"core/core_classes/esp_config/#espconfig-class","text":"The Esp_Config class is used on the ESP to read the configuration file from SPIFFS and to make the its contents available through getFkt() functions. The class is implemented as singelton. Therefore the normal way to get an object of the class is to call getInstance() and then a pointer to the object will be returned. To read the config file you have to call only once the readConfig() function of the EspConfig object. Attention It is important to call readConfig() at the beginning in Arduinos Setup() because other functionallitys like EspConenctionHandler use the class in there implementations. This class uses the class Esp_Spiffs to read the SPIFFS and the library ArduinoJson.h to parse the json file.","title":"EspConfig Class"},{"location":"core/core_classes/esp_connection_handler/","text":"Purpose The aim of the connection handler is to manage the Wifi connection and the TLS MQTT connection to the AWS broker. Implementation Setup In the Setup() the initialization of EspMQTT , EspNTP and EspWifi is done. To do this, the necessary configuration information is read from the configuration file with the help of EspConfig . The information is used to establish a first Wifi connection, to pass the configuration to MQTT and also to set the time zone of the ntp. Loop Now, this is where the actual main function of the connection handler comes into play. To automatically handle connecting and reconnecting to Wifi and the mqtt broker following statemachine is used. States : CONNECT_WIFI Initial state. Here the state machine connects the device to the wifi and changes to CONNECT_MQTT when the Wifi is connected. CONNECT_MQTT Checks if Wifi is connected and switches to CONNECT_WIFI if neccessary. Establishes MQTT connection and sends an init message to the aws broker. When the connection is established, the statemachine switches to CONNECTED . CONNECTED In this state the Wifi and MQTT connection is constantly checked and in case of a connection loss the Stemachine switches either to CONNECT_MQTT or to CONNECT_WIFI . When the state machine is called in code, it returns the current state. If the returned state is CONNECTED , then this signals to the [scheduler] (insert TODO link to sceduler doku) that everything is ready and it can start sending data. The state machine is designed not to block the program during execution. This means, for example, that when the program reconnects to the Wifi, it calls the reconnect function and then exits the state machine instead of waiting in the state machine until the Wifi is connected. This ensures that the Loop() is executed continuously and allows the user to use a watchdog or put custom code after the sceduler in the Loop() which is then executed continuously. EspConenctionHandler Class The class implements the functionallity descrribed before. The stetp() function of the class is called in Arduinos Setup() and it handles all the setup functionallity described above. Attention We assume that you use the EspConfig in other places in your program and therefore it is important that you call the readConfig() function in Setup() before calling EspConenctionHandler.stetp() . The runHadler() function of the class implements the statemachine. This function is called in Arduinos Loop() and it returns the actuall state. The state is of the type enum connection_states . The class uses the EspMQTT , EspNTP , EspConfig , EspJson and EspWifi classes of the core.","title":"Connection Handler"},{"location":"core/core_classes/esp_connection_handler/#purpose","text":"The aim of the connection handler is to manage the Wifi connection and the TLS MQTT connection to the AWS broker.","title":"Purpose"},{"location":"core/core_classes/esp_connection_handler/#implementation","text":"","title":"Implementation"},{"location":"core/core_classes/esp_connection_handler/#setup","text":"In the Setup() the initialization of EspMQTT , EspNTP and EspWifi is done. To do this, the necessary configuration information is read from the configuration file with the help of EspConfig . The information is used to establish a first Wifi connection, to pass the configuration to MQTT and also to set the time zone of the ntp.","title":"Setup"},{"location":"core/core_classes/esp_connection_handler/#loop","text":"Now, this is where the actual main function of the connection handler comes into play. To automatically handle connecting and reconnecting to Wifi and the mqtt broker following statemachine is used. States : CONNECT_WIFI Initial state. Here the state machine connects the device to the wifi and changes to CONNECT_MQTT when the Wifi is connected. CONNECT_MQTT Checks if Wifi is connected and switches to CONNECT_WIFI if neccessary. Establishes MQTT connection and sends an init message to the aws broker. When the connection is established, the statemachine switches to CONNECTED . CONNECTED In this state the Wifi and MQTT connection is constantly checked and in case of a connection loss the Stemachine switches either to CONNECT_MQTT or to CONNECT_WIFI . When the state machine is called in code, it returns the current state. If the returned state is CONNECTED , then this signals to the [scheduler] (insert TODO link to sceduler doku) that everything is ready and it can start sending data. The state machine is designed not to block the program during execution. This means, for example, that when the program reconnects to the Wifi, it calls the reconnect function and then exits the state machine instead of waiting in the state machine until the Wifi is connected. This ensures that the Loop() is executed continuously and allows the user to use a watchdog or put custom code after the sceduler in the Loop() which is then executed continuously.","title":"Loop"},{"location":"core/core_classes/esp_connection_handler/#espconenctionhandler-class","text":"The class implements the functionallity descrribed before. The stetp() function of the class is called in Arduinos Setup() and it handles all the setup functionallity described above. Attention We assume that you use the EspConfig in other places in your program and therefore it is important that you call the readConfig() function in Setup() before calling EspConenctionHandler.stetp() . The runHadler() function of the class implements the statemachine. This function is called in Arduinos Loop() and it returns the actuall state. The state is of the type enum connection_states . The class uses the EspMQTT , EspNTP , EspConfig , EspJson and EspWifi classes of the core.","title":"EspConenctionHandler Class"},{"location":"core/core_classes/esp_keys/","text":"Keys and Certificates Why do we need a key and certificate files? To establish a TLS connection with device authentification the following three files are necessary: Privat Key (esp32-d1mini-01.private.key) Device Certificate (esp32-d1mini-01.cert.crt) Root Certificate (root-CA.pem) You get these files from AWS and the process is described here. These three files are stored on the SPIFFS . To store them in the file system you just have to put the files together with the config file into the data directory and then follow the upload process which is described here . Attention It is important that the files have exactly the same name as seen in the brackets above. Keys Class The purpose of this class is to read the three files from the file system and make them accessible by getFkt() functions. The files are read first by calling the begin() function of the class. The class uses the EspSpiffs class to read from the file system.","title":"Keys"},{"location":"core/core_classes/esp_keys/#keys-and-certificates","text":"","title":"Keys and Certificates"},{"location":"core/core_classes/esp_keys/#why-do-we-need-a-key-and-certificate-files","text":"To establish a TLS connection with device authentification the following three files are necessary: Privat Key (esp32-d1mini-01.private.key) Device Certificate (esp32-d1mini-01.cert.crt) Root Certificate (root-CA.pem) You get these files from AWS and the process is described here. These three files are stored on the SPIFFS . To store them in the file system you just have to put the files together with the config file into the data directory and then follow the upload process which is described here . Attention It is important that the files have exactly the same name as seen in the brackets above.","title":"Why do we need a key and certificate files?"},{"location":"core/core_classes/esp_keys/#keys-class","text":"The purpose of this class is to read the three files from the file system and make them accessible by getFkt() functions. The files are read first by calling the begin() function of the class. The class uses the EspSpiffs class to read from the file system.","title":"Keys Class"},{"location":"core/core_classes/esp_logger/","text":"Logger Purpose The purpose of the logger is to log messages with different log levels such as info, debug in a file on the SPIFFS and print the information either at the beginning of the program via the serial monitor or directly during the program, depending on the configuration The aim of these is to inform the user about the device status and to simplify and speed up debugging. Implementation The configuration described below is passed to the program via the config file . Log levels For the logging one of the following log levels can be selected: LOG_LEVEL_OFF No logging. LOG_LEVEL_FATAL Designates very severe error events that will presumably lead the application to abort. LOG_LEVEL_ERROR Designates error events that might still allow the application to continue running. LOG_LEVEL_WARNING Designates potentially harmful situations. LOG_LEVEL_INFO Designates informational messages that highlight the progress of the application at coarse-grained level. LOG_LEVEL_DEBUG Designates fine-grained informational events that are most useful to debug an application. Note For example, if INFO is selected, WARNING, ERROR and FATAL messages will still be logged, but DEBUG messages will not. This is how the levels work. Logging For the output one of the following options can be selected: LOG_OUTPUT_SERIAL_DIRECT Logging events are directly printed over serial interface when they occure. LOG_OUTPUT_SERIAL_BEGIN Logging events are stored in the SPIFFS and printed over the serial interface at the start of the program. LOG_OUTPUT_SERIAL_DIRECT_BEGIN Comibination of LOG_OUTPUT_SERIAL_DIRECT and LOG_OUTPUT_SERIAL_BEGIN . LOG_OUTPUT_OFF Not output at all. Log file storage The logged information is stored in three files on the SPIFFS. Each has a length of 100 lines. This is determined by the LOG_FILE_MAX_ROWS definition. This limits the logging to a total of 300 messages with the purpose of preventing Flash from becoming completely full if the program runs for a very long time. When all three files are full, the logger starts again with the first file and overwrites it. EspLogger These class implements the functionality described above. The class is implemented as singelton. Therefore the normal way to get an object of the class is to call getInstance() and then a pointer to the object will be returned. By calling logBegin(log_level, log_output_level) the logger is initialized and the logged messages from the last programm call is depending on the log_output_level printed to the serial monitor. The parameters log_level and log_output_level are stored in the configuration file and can be accessed using the Esp_Config class. In your code you can call on of the following functions to log a message with a specific log level. logFatal(message) ; logError(message) ; logWarning(message) ; logInfo(message) ; logDebug(message) ; Note The logger automatically adds an appropriate label and timestamp to your message. This means that you only have to worry about the content of the message and the logger takes care of the rest. The class uses the EspSpiffs to access SPIFFS and the Ntp class to get the current time.","title":"Logger"},{"location":"core/core_classes/esp_logger/#logger","text":"","title":"Logger"},{"location":"core/core_classes/esp_logger/#purpose","text":"The purpose of the logger is to log messages with different log levels such as info, debug in a file on the SPIFFS and print the information either at the beginning of the program via the serial monitor or directly during the program, depending on the configuration The aim of these is to inform the user about the device status and to simplify and speed up debugging.","title":"Purpose"},{"location":"core/core_classes/esp_logger/#implementation","text":"The configuration described below is passed to the program via the config file .","title":"Implementation"},{"location":"core/core_classes/esp_logger/#log-levels","text":"For the logging one of the following log levels can be selected: LOG_LEVEL_OFF No logging. LOG_LEVEL_FATAL Designates very severe error events that will presumably lead the application to abort. LOG_LEVEL_ERROR Designates error events that might still allow the application to continue running. LOG_LEVEL_WARNING Designates potentially harmful situations. LOG_LEVEL_INFO Designates informational messages that highlight the progress of the application at coarse-grained level. LOG_LEVEL_DEBUG Designates fine-grained informational events that are most useful to debug an application. Note For example, if INFO is selected, WARNING, ERROR and FATAL messages will still be logged, but DEBUG messages will not. This is how the levels work.","title":"Log levels"},{"location":"core/core_classes/esp_logger/#logging","text":"For the output one of the following options can be selected: LOG_OUTPUT_SERIAL_DIRECT Logging events are directly printed over serial interface when they occure. LOG_OUTPUT_SERIAL_BEGIN Logging events are stored in the SPIFFS and printed over the serial interface at the start of the program. LOG_OUTPUT_SERIAL_DIRECT_BEGIN Comibination of LOG_OUTPUT_SERIAL_DIRECT and LOG_OUTPUT_SERIAL_BEGIN . LOG_OUTPUT_OFF Not output at all.","title":"Logging"},{"location":"core/core_classes/esp_logger/#log-file-storage","text":"The logged information is stored in three files on the SPIFFS. Each has a length of 100 lines. This is determined by the LOG_FILE_MAX_ROWS definition. This limits the logging to a total of 300 messages with the purpose of preventing Flash from becoming completely full if the program runs for a very long time. When all three files are full, the logger starts again with the first file and overwrites it.","title":"Log file storage"},{"location":"core/core_classes/esp_logger/#esplogger","text":"These class implements the functionality described above. The class is implemented as singelton. Therefore the normal way to get an object of the class is to call getInstance() and then a pointer to the object will be returned. By calling logBegin(log_level, log_output_level) the logger is initialized and the logged messages from the last programm call is depending on the log_output_level printed to the serial monitor. The parameters log_level and log_output_level are stored in the configuration file and can be accessed using the Esp_Config class. In your code you can call on of the following functions to log a message with a specific log level. logFatal(message) ; logError(message) ; logWarning(message) ; logInfo(message) ; logDebug(message) ; Note The logger automatically adds an appropriate label and timestamp to your message. This means that you only have to worry about the content of the message and the logger takes care of the rest. The class uses the EspSpiffs to access SPIFFS and the Ntp class to get the current time.","title":"EspLogger"},{"location":"core/core_classes/esp_spiffs/","text":"SPIFFS Description SPIFFS (Serial Peripheral Interface Flash File System) is a simple file system which is located on the ESP flash storage. The advantage of the file system is that we can change the configuration and tls certificate files independently of the source code. Uploade to SPIFFS To uplode the SPIFFS we suggest to use PlatformIO but you are also free to use a other option like the Ardunio-IDE . How To uploade the SPIFFS with PlatformIO Connect your ESP to your computer using a USB cable. In VS Code, open the PlatformIO extension on the left side and then open the esp device folder under PROJECT TASKS . You should then see a view similar to the following image. Click on Build Filesystem Image and wait unitl the task finishes. This is indicated when SUCCESS is printed at the terminal. What happens is that the content in the top directory data is used to build a spiffs image. Click on Upload Filesystem Image . Now the previously build image is uploaded to the flash storage of the connected ESP. EspSpiffs class The EspSpiffs class is used to read the SPIFFS on the ESP in a structured way. The class is used by the other classes Keys , Esp_Config and Esp_Logger . This class uses the library SPIFFS.h from Espressif. It is described here .","title":"Spiffs"},{"location":"core/core_classes/esp_spiffs/#spiffs","text":"","title":"SPIFFS"},{"location":"core/core_classes/esp_spiffs/#description","text":"SPIFFS (Serial Peripheral Interface Flash File System) is a simple file system which is located on the ESP flash storage. The advantage of the file system is that we can change the configuration and tls certificate files independently of the source code.","title":"Description"},{"location":"core/core_classes/esp_spiffs/#uploade-to-spiffs","text":"To uplode the SPIFFS we suggest to use PlatformIO but you are also free to use a other option like the Ardunio-IDE . How To uploade the SPIFFS with PlatformIO Connect your ESP to your computer using a USB cable. In VS Code, open the PlatformIO extension on the left side and then open the esp device folder under PROJECT TASKS . You should then see a view similar to the following image. Click on Build Filesystem Image and wait unitl the task finishes. This is indicated when SUCCESS is printed at the terminal. What happens is that the content in the top directory data is used to build a spiffs image. Click on Upload Filesystem Image . Now the previously build image is uploaded to the flash storage of the connected ESP.","title":"Uploade to SPIFFS"},{"location":"core/core_classes/esp_spiffs/#espspiffs-class","text":"The EspSpiffs class is used to read the SPIFFS on the ESP in a structured way. The class is used by the other classes Keys , Esp_Config and Esp_Logger . This class uses the library SPIFFS.h from Espressif. It is described here .","title":"EspSpiffs class"},{"location":"core/core_classes/esp_wifi/","text":"EspWifi Class Purpose The aim of this class is to bundle the functionality for structured access to the WLAN connection in one class. This ensures that the WLAN connection is always accessed in the same way which helps to avoid errors. The class is used in the connection handler . The class uses the WiFi.h library from the Arduino ESP Core. How to use? For a intial wifi connection the function beginWifi(ssid, password) has to be called. The function passes the parameters ssid and password . These parameters are stored in the configuration file and can be accessed using the Esp_Config class.The current WLAN status can be checked with statusWifi() and the connection can be re-established with reconnectWifi() .","title":"Wifi"},{"location":"core/core_classes/esp_wifi/#espwifi-class","text":"","title":"EspWifi Class"},{"location":"core/core_classes/esp_wifi/#purpose","text":"The aim of this class is to bundle the functionality for structured access to the WLAN connection in one class. This ensures that the WLAN connection is always accessed in the same way which helps to avoid errors. The class is used in the connection handler . The class uses the WiFi.h library from the Arduino ESP Core.","title":"Purpose"},{"location":"core/core_classes/esp_wifi/#how-to-use","text":"For a intial wifi connection the function beginWifi(ssid, password) has to be called. The function passes the parameters ssid and password . These parameters are stored in the configuration file and can be accessed using the Esp_Config class.The current WLAN status can be checked with statusWifi() and the connection can be re-established with reconnectWifi() .","title":"How to use?"},{"location":"sensors/","text":"Sensors","title":"Sensors"},{"location":"sensors/#sensors","text":"","title":"Sensors"},{"location":"sensors/DHT22/","text":"DHT22 Type Temperature Humidity Specs Low cost 3 to 5V power and I/O 2.5mA max current use during conversion (while requesting data) Good for 0-100% humidity readings with 2-5% accuracy Good for -40 to 80\u00b0C temperature readings \u00b10.5\u00b0C accuracy No more than 0.5 Hz sampling rate (once every 2 seconds) Body size 27mm x 59mm x 13.5mm (1.05\" x 2.32\" x 0.53\") 3 wires 23cm long (9\") 27mm wide x 58.75mm tall x 13.30mm deep Description The AM2302 is a wired version of the DHT22, in a large plastic body. It is a basic, low-cost digital temperature and humidity sensor. It uses a capacitive humidity sensor and a thermistor to measure the surrounding air and spits out a digital signal on the data pin (no analog input pins needed). It's fairly simple to use but requires careful timing to grab data. The only real downside of this sensor is you can only get new data from it once every 2 seconds, so when using our library, sensor readings can be up to 2 seconds old. Simply connect the red 3-5V power, the yellow wire to your data input pin, and the black wire to ground. Although it uses a single wire to send data it is not Dallas One Wire compatible! If you want multiple sensors, each one must have its own data pin. Source Adafruit","title":"DHT22"},{"location":"sensors/DHT22/#dht22","text":"","title":"DHT22"},{"location":"sensors/DHT22/#type","text":"Temperature Humidity","title":"Type"},{"location":"sensors/DHT22/#specs","text":"Low cost 3 to 5V power and I/O 2.5mA max current use during conversion (while requesting data) Good for 0-100% humidity readings with 2-5% accuracy Good for -40 to 80\u00b0C temperature readings \u00b10.5\u00b0C accuracy No more than 0.5 Hz sampling rate (once every 2 seconds) Body size 27mm x 59mm x 13.5mm (1.05\" x 2.32\" x 0.53\") 3 wires 23cm long (9\") 27mm wide x 58.75mm tall x 13.30mm deep","title":"Specs"},{"location":"sensors/DHT22/#description","text":"The AM2302 is a wired version of the DHT22, in a large plastic body. It is a basic, low-cost digital temperature and humidity sensor. It uses a capacitive humidity sensor and a thermistor to measure the surrounding air and spits out a digital signal on the data pin (no analog input pins needed). It's fairly simple to use but requires careful timing to grab data. The only real downside of this sensor is you can only get new data from it once every 2 seconds, so when using our library, sensor readings can be up to 2 seconds old. Simply connect the red 3-5V power, the yellow wire to your data input pin, and the black wire to ground. Although it uses a single wire to send data it is not Dallas One Wire compatible! If you want multiple sensors, each one must have its own data pin.","title":"Description"},{"location":"sensors/DHT22/#source","text":"Adafruit","title":"Source"},{"location":"sensors/LPS25/","text":"LPS25 Type Temperature Pressure Specs 3,3 to 5V power and I/O Range: 260-1260 hPa Accuracy: 0.2 hPa after calibration +-1 hPa before calibration Maximum Sampling Rate: 25Hz Body size: 25mm X 25mm X 7,6mm Form Faktor: STEMMA QT / Qwiic Current Consumption: High resolution mode: 25\u00b5A low power mode: 4\u00b5A Communication Interface: I2C, SPI Description This absolute pressure sensor, ST LPS25HB can quickly and easily measure this air pressure, useful when you want to know about the weather (are we in a low pressure or high pressure system?) or to determine altitude, as the air thins out the higher we get above sea level. For example, at sea level, the official pressure level is 1013.25 hPa. You can use this sensor to measure the current pressure where you are right now, to compare. The LPS25 has a wide measurement range of 260-1260 hPa with 24-bit pressure data measurements that can be read up to 25 times a second (Hz), you can be confident that you always have an up to date and precise measurement. It's pretty dang accurate too, with the ability to measure within 0.2 hPa after calibration (\u00b1 1 hPa before calibration). Source Adafruit","title":"LPS25"},{"location":"sensors/LPS25/#lps25","text":"","title":"LPS25"},{"location":"sensors/LPS25/#type","text":"Temperature Pressure","title":"Type"},{"location":"sensors/LPS25/#specs","text":"3,3 to 5V power and I/O Range: 260-1260 hPa Accuracy: 0.2 hPa after calibration +-1 hPa before calibration Maximum Sampling Rate: 25Hz Body size: 25mm X 25mm X 7,6mm Form Faktor: STEMMA QT / Qwiic Current Consumption: High resolution mode: 25\u00b5A low power mode: 4\u00b5A Communication Interface: I2C, SPI","title":"Specs"},{"location":"sensors/LPS25/#description","text":"This absolute pressure sensor, ST LPS25HB can quickly and easily measure this air pressure, useful when you want to know about the weather (are we in a low pressure or high pressure system?) or to determine altitude, as the air thins out the higher we get above sea level. For example, at sea level, the official pressure level is 1013.25 hPa. You can use this sensor to measure the current pressure where you are right now, to compare. The LPS25 has a wide measurement range of 260-1260 hPa with 24-bit pressure data measurements that can be read up to 25 times a second (Hz), you can be confident that you always have an up to date and precise measurement. It's pretty dang accurate too, with the ability to measure within 0.2 hPa after calibration (\u00b1 1 hPa before calibration).","title":"Description"},{"location":"sensors/LPS25/#source","text":"Adafruit","title":"Source"},{"location":"sensors/SCD30/","text":"SCD30 Type Temperature Humidity CO2 Specs NDIR CO2 sensor technology Integrated temperature and humidity sensor Dual-channel detection for superior stability Small form factor: 35 mm x 23 mm x 7 mm Measurement range: 400 ppm \u2013 10.000 ppm Accuracy: \u00b1(30 ppm + 3%) Current consumption: 19 mA @ 1 meas. per 2 s. Fully calibrated and linearized Digital interface UART or I2C Description The SCD-30 is an NDIR sensor, which is a 'true' CO2 sensor, that will tell you the CO2 PPM (parts-per-million) composition of ambient air. Perfect for environmental sensing, scientific experiments, air quality and ventilation studies and more. Data is read over I2C, so it works very nicely with just about any microcontroller or microcomputer. Source Adafruit","title":"SCD30"},{"location":"sensors/SCD30/#scd30","text":"","title":"SCD30"},{"location":"sensors/SCD30/#type","text":"Temperature Humidity CO2","title":"Type"},{"location":"sensors/SCD30/#specs","text":"NDIR CO2 sensor technology Integrated temperature and humidity sensor Dual-channel detection for superior stability Small form factor: 35 mm x 23 mm x 7 mm Measurement range: 400 ppm \u2013 10.000 ppm Accuracy: \u00b1(30 ppm + 3%) Current consumption: 19 mA @ 1 meas. per 2 s. Fully calibrated and linearized Digital interface UART or I2C","title":"Specs"},{"location":"sensors/SCD30/#description","text":"The SCD-30 is an NDIR sensor, which is a 'true' CO2 sensor, that will tell you the CO2 PPM (parts-per-million) composition of ambient air. Perfect for environmental sensing, scientific experiments, air quality and ventilation studies and more. Data is read over I2C, so it works very nicely with just about any microcontroller or microcomputer.","title":"Description"},{"location":"sensors/SCD30/#source","text":"Adafruit","title":"Source"},{"location":"sensors/VEML7700/","text":"VEML7700 Type Brightness Specs Can be used with 3.3V or 5V logic level Ambient light detection from 0 to 120 LUX with resoltion down to 0.0036 lx/ct No more than 1 Hz sampling rate (once every second) Body size: 16.5mm x 16.5mm x 2.1mm Communication Interface: I2C Includes an voltage regulator which provides 3.3V and 100mA 5 pins: Vin, GND, 3Vo(3.3V output), SCL, SDA Description The sensor has 16-bit dynamic range for ambient light detection from 0 lux to about 120k lux with resolution down to 0.0036 lx/ct, with software-adjustable gain and integration times. Source Adafruit","title":"VEML7700"},{"location":"sensors/VEML7700/#veml7700","text":"","title":"VEML7700"},{"location":"sensors/VEML7700/#type","text":"Brightness","title":"Type"},{"location":"sensors/VEML7700/#specs","text":"Can be used with 3.3V or 5V logic level Ambient light detection from 0 to 120 LUX with resoltion down to 0.0036 lx/ct No more than 1 Hz sampling rate (once every second) Body size: 16.5mm x 16.5mm x 2.1mm Communication Interface: I2C Includes an voltage regulator which provides 3.3V and 100mA 5 pins: Vin, GND, 3Vo(3.3V output), SCL, SDA","title":"Specs"},{"location":"sensors/VEML7700/#description","text":"The sensor has 16-bit dynamic range for ambient light detection from 0 lux to about 120k lux with resolution down to 0.0036 lx/ct, with software-adjustable gain and integration times.","title":"Description"},{"location":"sensors/VEML7700/#source","text":"Adafruit","title":"Source"},{"location":"sensors/implementation/","text":"Implementation The functionality of the sensors within the framework is defined by the following 3 independently acting functions. setup In the setup function, which is called once when the application is started, the framework initializes the respective sensor. void EspSensor . setup (){}; When implementing a new sensor, any initialization of the sensor in the sample code must be integrated into this function. setValue The set_value function is called cyclically with the help of the scheduler and determines the current measured value and stores it in the specified variable. void EspSensor . setValue ( float value ) When implementing a new sensor, the measured value for each measurement determined by the sample code or function must be stored directly in the variable provided for the physical sensor. update With the update function, which is also called cyclically with the help of the scheduler, the variables containing the data of the sensor including the measurement data are uploaded to the MQTT broker. void EspSensor . update () When implementing a new sensor, as long as the sensor object was created correctly, no changes need to be made in the update function. Only the physical sensors must be selected. Implementing a new Sensor If a sensor should be added that is not yet integrated in the framework, this is done by first defining the new sensor. It is recommended to use the example code of the manufacturer for the respective platform. The type of sensor is defined based on the physical quantities that the sensor measures. When creating the subclass of the sensor, these quantities must be defined by their own sensor objects within the subclass. If libraries provided by the manufacturer are required, these must be included. The functions which provide the use of the sensor should always be globally related to the respective sensor to be integrated. For example, with the DHT22, which measures air temperature and humidity, the measurement of both sensor objects is started with a call to setValue.","title":"Implementation"},{"location":"sensors/implementation/#implementation","text":"The functionality of the sensors within the framework is defined by the following 3 independently acting functions.","title":"Implementation"},{"location":"sensors/implementation/#setup","text":"In the setup function, which is called once when the application is started, the framework initializes the respective sensor. void EspSensor . setup (){}; When implementing a new sensor, any initialization of the sensor in the sample code must be integrated into this function.","title":"setup"},{"location":"sensors/implementation/#setvalue","text":"The set_value function is called cyclically with the help of the scheduler and determines the current measured value and stores it in the specified variable. void EspSensor . setValue ( float value ) When implementing a new sensor, the measured value for each measurement determined by the sample code or function must be stored directly in the variable provided for the physical sensor.","title":"setValue"},{"location":"sensors/implementation/#update","text":"With the update function, which is also called cyclically with the help of the scheduler, the variables containing the data of the sensor including the measurement data are uploaded to the MQTT broker. void EspSensor . update () When implementing a new sensor, as long as the sensor object was created correctly, no changes need to be made in the update function. Only the physical sensors must be selected.","title":"update"},{"location":"sensors/implementation/#implementing-a-new-sensor","text":"If a sensor should be added that is not yet integrated in the framework, this is done by first defining the new sensor. It is recommended to use the example code of the manufacturer for the respective platform. The type of sensor is defined based on the physical quantities that the sensor measures. When creating the subclass of the sensor, these quantities must be defined by their own sensor objects within the subclass. If libraries provided by the manufacturer are required, these must be included. The functions which provide the use of the sensor should always be globally related to the respective sensor to be integrated. For example, with the DHT22, which measures air temperature and humidity, the measurement of both sensor objects is started with a call to setValue.","title":"Implementing a new Sensor"},{"location":"sensors/introduction/","text":"Introduction In order to use sensors for the measurement of data by means of the framework, an own concept for the processing of these data was developed.To limit the massive selection of sensors, the use was limited to 2 different types of connections. These connection types are I2C and One-Wire. Since most of the sensors available on the market can handle at least one of these connection types, the implementation of other protocols such as UART or SPI could be omitted for the time being. Since the power supply is circuit-dependent, no consideration had to be given to the supply voltage during the development of the framework. If the adapter board developed in the project should be used, it is recommended to use sensors with a supply voltage of 5V. The following chapters are intended to show the user which sensors are integrated in the framework by default and also to provide a brief guide to the implementation of new sensors.","title":"Introduction"},{"location":"sensors/introduction/#introduction","text":"In order to use sensors for the measurement of data by means of the framework, an own concept for the processing of these data was developed.To limit the massive selection of sensors, the use was limited to 2 different types of connections. These connection types are I2C and One-Wire. Since most of the sensors available on the market can handle at least one of these connection types, the implementation of other protocols such as UART or SPI could be omitted for the time being. Since the power supply is circuit-dependent, no consideration had to be given to the supply voltage during the development of the framework. If the adapter board developed in the project should be used, it is recommended to use sensors with a supply voltage of 5V. The following chapters are intended to show the user which sensors are integrated in the framework by default and also to provide a brief guide to the implementation of new sensors.","title":"Introduction"},{"location":"setup/documentation/","text":"Documentation The documentation is generated by MkDocs with the Material for MkDocs Theme. MkDocs is a static site generator wich uses Markdown as markup language. For a Markdown cheat sheet click here . Local build Use the following command to build a local instance: mkdocs serve The documentation can be accessed on the local address shown in the terminal ( http://localhost:8000 ) Hint mkdocs handles updates of your .md code automatically. You don't need to run the command twice when updates are made. Assuming you are still in the same session Deploy When the documentation is ready it can be uploaded to GitHub using: mkdocs gh-deploy This will automatically build an upload the site to GitHub using the branch gh-pages . Warning Please avoid modifying the branch gh-pages manually. Useful Commands Diagrams Diagrams can be created by using mermaid . Mermaid can be used by creating a code-block with the mermaid language tag. ```mermaid <your diagram> ```","title":"Documentation"},{"location":"setup/documentation/#documentation","text":"The documentation is generated by MkDocs with the Material for MkDocs Theme. MkDocs is a static site generator wich uses Markdown as markup language. For a Markdown cheat sheet click here .","title":"Documentation"},{"location":"setup/documentation/#local-build","text":"Use the following command to build a local instance: mkdocs serve The documentation can be accessed on the local address shown in the terminal ( http://localhost:8000 ) Hint mkdocs handles updates of your .md code automatically. You don't need to run the command twice when updates are made. Assuming you are still in the same session","title":"Local build"},{"location":"setup/documentation/#deploy","text":"When the documentation is ready it can be uploaded to GitHub using: mkdocs gh-deploy This will automatically build an upload the site to GitHub using the branch gh-pages . Warning Please avoid modifying the branch gh-pages manually.","title":"Deploy"},{"location":"setup/documentation/#useful-commands","text":"","title":"Useful Commands"},{"location":"setup/documentation/#diagrams","text":"Diagrams can be created by using mermaid . Mermaid can be used by creating a code-block with the mermaid language tag. ```mermaid <your diagram> ```","title":"Diagrams"},{"location":"setup/setup/","text":"Getting started First steps Requirements Make sure that python 3.8 or higher and pip3 are installed on your PC. Next ensure that you have installed a capable text editor like VS Code (any other editor should work fine as long a you can use the necessary plugins for this project). Note If your are using VS Code you can install some very helpful extensions . Those extension are optional but will simplify writing code. Check out the extensions tab further below. Dependencies The project requires some python packages which are essential f.e. for embedded development (PlatformIO) or for building docs (Mkdocs). You can install them by using pip3 . Make sure that you are in the projects root folder Linux / macOS Windows pip3 install -r requirements.txt python3 -m pip install -r requirements.txt After the installation you should be able to use mkdocs and pio , which are the CLI tools for the documentation and platformIO. Hint For more information about mkdocs head to Documentation Extensions This list contains some good extensions which make developing code way easier. As always, this is just a short summary of what's possible. If you want to dig deeper into Extensions and Tools for VS Code, visit their docs . PlatformIO C++ C++ Extension Pack C/C++ Themes Python Pylance Mkdocs","title":"Getting started"},{"location":"setup/setup/#getting-started","text":"","title":"Getting started"},{"location":"setup/setup/#first-steps","text":"","title":"First steps"},{"location":"setup/setup/#requirements","text":"Make sure that python 3.8 or higher and pip3 are installed on your PC. Next ensure that you have installed a capable text editor like VS Code (any other editor should work fine as long a you can use the necessary plugins for this project). Note If your are using VS Code you can install some very helpful extensions . Those extension are optional but will simplify writing code. Check out the extensions tab further below.","title":"Requirements"},{"location":"setup/setup/#dependencies","text":"The project requires some python packages which are essential f.e. for embedded development (PlatformIO) or for building docs (Mkdocs). You can install them by using pip3 . Make sure that you are in the projects root folder Linux / macOS Windows pip3 install -r requirements.txt python3 -m pip install -r requirements.txt After the installation you should be able to use mkdocs and pio , which are the CLI tools for the documentation and platformIO. Hint For more information about mkdocs head to Documentation","title":"Dependencies"},{"location":"setup/setup/#extensions","text":"This list contains some good extensions which make developing code way easier. As always, this is just a short summary of what's possible. If you want to dig deeper into Extensions and Tools for VS Code, visit their docs . PlatformIO C++ C++ Extension Pack C/C++ Themes Python Pylance Mkdocs","title":"Extensions"},{"location":"setup/structure/","text":"Structure This repository combines the source code, the documentation and the editor setup at once. Therefore it is crucial to understand the directories structure. The following folders are most likely to be changed by future developers: /src Here all every line of C++ code is put. Within this directory there are sub-folders in order to keep a tidy structure. When adding a new folder for a new structural element, give this folder a meaningful name. /scripts This folders intention is to store essential scripts which facilitate coding. Therefore all types of scripts can be put here ( python , shell etc.). /docs The /docs folder (like the name implies) stores every line of markdown code. In the future the intention of this project is to integrate a automatic doc generation tool like Doxygen . Doxygen allows the developer to write doc-strings which can be compiled into readable markdown code.","title":"Structure"},{"location":"setup/structure/#structure","text":"This repository combines the source code, the documentation and the editor setup at once. Therefore it is crucial to understand the directories structure. The following folders are most likely to be changed by future developers:","title":"Structure"},{"location":"setup/structure/#src","text":"Here all every line of C++ code is put. Within this directory there are sub-folders in order to keep a tidy structure. When adding a new folder for a new structural element, give this folder a meaningful name.","title":"/src"},{"location":"setup/structure/#scripts","text":"This folders intention is to store essential scripts which facilitate coding. Therefore all types of scripts can be put here ( python , shell etc.).","title":"/scripts"},{"location":"setup/structure/#docs","text":"The /docs folder (like the name implies) stores every line of markdown code. In the future the intention of this project is to integrate a automatic doc generation tool like Doxygen . Doxygen allows the developer to write doc-strings which can be compiled into readable markdown code.","title":"/docs"},{"location":"setup/coding-style/cpp/","text":"C++ coding style Next to consistency as a main aspect of good code, the second most important aspect is a certain style which the average c++ programmer is capable to read and understand properly. Therefore the following documents states the essential naming conventions. Hint Here is a link for a more detailed dive into `c++ core guidelines' Style guide by the Barr Group: Style Guide Naming conventions Variables The name of a variable should be as accurate as possible and as short as possible at the same time. Example: // don't int x ; x = 10 + 5 ; // do int sum sum = 10 + 5 ; A variable can be used in two different scenarios. Global/Local variables Global/Local variables should be defined in a snake_case style. Example: int global_variable ; Private variables Private variables should be defined the same way as global variables. The main difference for private variables is a defined prefix _ . Example: int _private_variable ; Constants & Preprocessor Values Constants are expression with a fixed value. They are defined with the key `const. The naming convention for constants and preprocessor values prescribes that all letters are upper case letters with snake case subdivision Example: const int PI_VALUE = 3.14159 ; Functions A function is a block of code which runs when it's called. Data in form of parameters can be passed into a function. Functions can be written as non-returning and returning type. Functions should start with a lower case letter. The following word should be upper case . This method is called camelCase Example: void exampleFunktion () { // do some stuff } Classes (Types, Template parameters) C++ is a object-oriented programming language. Therefore it's all about creating objects which contain both data and functions for a certain task. In the example picture shown above, there is the class car defined, which has certain methods and attributes . This class can be used to create different objects which share the same set of properties with different values. A class should be defined with all upper case (PascalCase) notation. Example: class Car { public : string brand ; int max_speed ; int power ; Car ( string ini_brand , int ini_speed , ini_power ) { brand = ini_brand ; max_speed = ini_speed ; power = ini_power ; } private : int _current_speed ; }; void GeneralCar::setSpeed ( int new_speed ) { _current_speed = new_speed ; } int main () { // declaration of two objects Car car1 ( \"Auto1\" , 200 , 100 ); Car car2 ( \"Auto2\" , 300 , 200 ); //setting the speed car1 . setSpeed ( 250 ); return 0 ; } Braces In order to get a clear structure the following braces scheme should be taking into account when programming. Every left brace ( { ) should be appear by itself on the line below it the block it opens. The corresponding right brace ( } ) should be placed by itself in the same position th appropriate number of lines later in the file. Example if ( car . speed == \"fast\" ) { car . price = \"high\" ; } else { car . price = \"low\" ; } The indentation should always be made with a tab . For every hierarchy step one tab has to be added. Example if ( car . speed == \"fast\" ) { car . price = \"high\" ; if ( car . weight >= 1000 ) { car . type = \"Truck\" ; } } else { car . price = \"low\" ; } Comments If the section of code is not clearly understandable there should be a short description of the current function in form of a comment. For commenting block // should be used. Warning Inline comments should be used with caution, because they can cause chaotic code. Example DON'T // divides up two double values double division ( double dividend , double divisor ) { // this is the result variable double div ; // the result is calculated here: div = dividend / divisor ; // here the result is given back return div ; }","title":"C++ coding style"},{"location":"setup/coding-style/cpp/#c-coding-style","text":"Next to consistency as a main aspect of good code, the second most important aspect is a certain style which the average c++ programmer is capable to read and understand properly. Therefore the following documents states the essential naming conventions. Hint Here is a link for a more detailed dive into `c++ core guidelines' Style guide by the Barr Group: Style Guide","title":"C++ coding style"},{"location":"setup/coding-style/cpp/#naming-conventions","text":"","title":"Naming conventions"},{"location":"setup/coding-style/cpp/#variables","text":"The name of a variable should be as accurate as possible and as short as possible at the same time. Example: // don't int x ; x = 10 + 5 ; // do int sum sum = 10 + 5 ; A variable can be used in two different scenarios. Global/Local variables Global/Local variables should be defined in a snake_case style. Example: int global_variable ; Private variables Private variables should be defined the same way as global variables. The main difference for private variables is a defined prefix _ . Example: int _private_variable ;","title":"Variables"},{"location":"setup/coding-style/cpp/#constants-preprocessor-values","text":"Constants are expression with a fixed value. They are defined with the key `const. The naming convention for constants and preprocessor values prescribes that all letters are upper case letters with snake case subdivision Example: const int PI_VALUE = 3.14159 ;","title":"Constants &amp; Preprocessor Values"},{"location":"setup/coding-style/cpp/#functions","text":"A function is a block of code which runs when it's called. Data in form of parameters can be passed into a function. Functions can be written as non-returning and returning type. Functions should start with a lower case letter. The following word should be upper case . This method is called camelCase Example: void exampleFunktion () { // do some stuff }","title":"Functions"},{"location":"setup/coding-style/cpp/#classes-types-template-parameters","text":"C++ is a object-oriented programming language. Therefore it's all about creating objects which contain both data and functions for a certain task. In the example picture shown above, there is the class car defined, which has certain methods and attributes . This class can be used to create different objects which share the same set of properties with different values. A class should be defined with all upper case (PascalCase) notation. Example: class Car { public : string brand ; int max_speed ; int power ; Car ( string ini_brand , int ini_speed , ini_power ) { brand = ini_brand ; max_speed = ini_speed ; power = ini_power ; } private : int _current_speed ; }; void GeneralCar::setSpeed ( int new_speed ) { _current_speed = new_speed ; } int main () { // declaration of two objects Car car1 ( \"Auto1\" , 200 , 100 ); Car car2 ( \"Auto2\" , 300 , 200 ); //setting the speed car1 . setSpeed ( 250 ); return 0 ; }","title":"Classes (Types, Template parameters)"},{"location":"setup/coding-style/cpp/#braces","text":"In order to get a clear structure the following braces scheme should be taking into account when programming. Every left brace ( { ) should be appear by itself on the line below it the block it opens. The corresponding right brace ( } ) should be placed by itself in the same position th appropriate number of lines later in the file. Example if ( car . speed == \"fast\" ) { car . price = \"high\" ; } else { car . price = \"low\" ; } The indentation should always be made with a tab . For every hierarchy step one tab has to be added. Example if ( car . speed == \"fast\" ) { car . price = \"high\" ; if ( car . weight >= 1000 ) { car . type = \"Truck\" ; } } else { car . price = \"low\" ; }","title":"Braces"},{"location":"setup/coding-style/cpp/#comments","text":"If the section of code is not clearly understandable there should be a short description of the current function in form of a comment. For commenting block // should be used. Warning Inline comments should be used with caution, because they can cause chaotic code. Example DON'T // divides up two double values double division ( double dividend , double divisor ) { // this is the result variable double div ; // the result is calculated here: div = dividend / divisor ; // here the result is given back return div ; }","title":"Comments"},{"location":"setup/coding-style/git/","text":"Branching System Commit Style In order to achieve a uniform naming for commit messages the following commit style should be used when creating a new commit message. Keyword Description ADD Is used if there is a new change in the code. f.e git commit -m \"ADD function XY()\" FIX Used for minor changes, bugfixes of an already existing part of the code. f.e git commit -m \"FIX functionality of XY\" REF Written short for: REFACTOR. Is used when there is a major change in multiple code-segments and the structure of the code is reworked. f.e git commit -m \"UPDATE setup of analog sensors\" Creating Pull Requests In order to keep the master branch clean and functioning the prototyping repository has a branch protection rule . When someone wants to merge code onto the master branche a pull request has to be made. The pull request informs the admin of the repository to have a look over the code in order to approve if this its functioning and good code which can be merged without hesitation. In order to understand how to create a pull request have a look here source: https://codeburst.io/git-and-github-in-a-nutshell-b0a3cc06458f \u21a9","title":"Branching System"},{"location":"setup/coding-style/git/#branching-system","text":"","title":"Branching System"},{"location":"setup/coding-style/git/#commit-style","text":"In order to achieve a uniform naming for commit messages the following commit style should be used when creating a new commit message. Keyword Description ADD Is used if there is a new change in the code. f.e git commit -m \"ADD function XY()\" FIX Used for minor changes, bugfixes of an already existing part of the code. f.e git commit -m \"FIX functionality of XY\" REF Written short for: REFACTOR. Is used when there is a major change in multiple code-segments and the structure of the code is reworked. f.e git commit -m \"UPDATE setup of analog sensors\"","title":"Commit Style"},{"location":"setup/coding-style/git/#creating-pull-requests","text":"In order to keep the master branch clean and functioning the prototyping repository has a branch protection rule . When someone wants to merge code onto the master branche a pull request has to be made. The pull request informs the admin of the repository to have a look over the code in order to approve if this its functioning and good code which can be merged without hesitation. In order to understand how to create a pull request have a look here source: https://codeburst.io/git-and-github-in-a-nutshell-b0a3cc06458f \u21a9","title":"Creating Pull Requests"},{"location":"software-planning/connection-handler/","text":"Class - ConnectionHandler The purpose of this class is to ensure that every remote connection is alive and maintained (Wifi, MQTT to broker). Features The main structure contains a state machine which handles the connection to the Wifi, sets up a TLS client for MQTT, enables a connection to the AWS MQTT Broker. Structure Basic UML in order to understand the structure of the class classDiagram class ConnectionHandler{ +ESPWifi esp_wifi +ESPLogger esp_logger +EspConfig *esp_config +MQTTClient *mqtt_client +enum states -ConnectionHandler() -state connectionStateMachine() }","title":"Class - ConnectionHandler"},{"location":"software-planning/connection-handler/#class-connectionhandler","text":"The purpose of this class is to ensure that every remote connection is alive and maintained (Wifi, MQTT to broker).","title":"Class - ConnectionHandler"},{"location":"software-planning/connection-handler/#features","text":"The main structure contains a state machine which handles the connection to the Wifi, sets up a TLS client for MQTT, enables a connection to the AWS MQTT Broker.","title":"Features"},{"location":"software-planning/connection-handler/#structure","text":"Basic UML in order to understand the structure of the class classDiagram class ConnectionHandler{ +ESPWifi esp_wifi +ESPLogger esp_logger +EspConfig *esp_config +MQTTClient *mqtt_client +enum states -ConnectionHandler() -state connectionStateMachine() }","title":"Structure"},{"location":"software-planning/sensors/","text":"Structure for implementing Sensor Modules A sensor module is a a type of measuring device which can be attached to the ESP32 via a serial connection (I2C, 1WIRE). The sensors of the module measures physical quantities like temperature or humidity, etc. In order to get a general form for adding new sensor modules to the framework the following points should be taken into account: A newly written class for a sensor module should always implement the EspComponent superclass. That is necessary to ensure a general structure when calling the new sensor modules object. The measured physical values which can be read of the sensor should be fed into a new instance of the sensor class. Structure Basic UML in order to understand the structure. The implemented sensor module DHT22 is just an example. classDiagram class EspComponent{ -void setup() -void setup(T setup_config) -void update() -void setValue() } class Sensor { +float sensor_value -char* sensor_type -char* unit -char* mqtt_topic -Sensor(char* sensor_type, char* mqtt_topic) -void setValue(float sensor_value) -void updateValue() } class DHT22 { -Sensor temperature -Sensor humidity -void setup() -void setValue() -void update() } EspComponent < |-- DHT22 Sensor --> DHT22 : contains","title":"Structure for implementing Sensor Modules"},{"location":"software-planning/sensors/#structure-for-implementing-sensor-modules","text":"A sensor module is a a type of measuring device which can be attached to the ESP32 via a serial connection (I2C, 1WIRE). The sensors of the module measures physical quantities like temperature or humidity, etc. In order to get a general form for adding new sensor modules to the framework the following points should be taken into account: A newly written class for a sensor module should always implement the EspComponent superclass. That is necessary to ensure a general structure when calling the new sensor modules object. The measured physical values which can be read of the sensor should be fed into a new instance of the sensor class.","title":"Structure for implementing Sensor Modules"},{"location":"software-planning/sensors/#structure","text":"Basic UML in order to understand the structure. The implemented sensor module DHT22 is just an example. classDiagram class EspComponent{ -void setup() -void setup(T setup_config) -void update() -void setValue() } class Sensor { +float sensor_value -char* sensor_type -char* unit -char* mqtt_topic -Sensor(char* sensor_type, char* mqtt_topic) -void setValue(float sensor_value) -void updateValue() } class DHT22 { -Sensor temperature -Sensor humidity -void setup() -void setValue() -void update() } EspComponent < |-- DHT22 Sensor --> DHT22 : contains","title":"Structure"}]}